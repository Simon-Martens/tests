To me the whole point of templating is that you have a textfile OUTSIDE of the program code that can determine the application look and feel. Like you can give a bunch of .tmpl files and data availablity specs to the frontend team. TEMPL templates get compiled into go code, then get compiled by the compiler. Whats the point of that? 
1) It adds not one but two compilation steps, since simple go tmpl files are just a bunch of tmpl files in a folder read in by go at runtime, not neccessary at compile time.
2) It intertwines go code, which is procedural, with template code, which is descriptive. But to be able to just differentiate between those two I always found to be the good kind of separation of concerns (reaching a state of kubernetes being the bad kind).

```go
    text := `
    <html><head>
    {{ block "head" . }}Default{{ end }}
        </head><body>
        {{ block "body" . }}Default Body{{ end }}
        </body></html>
    `
    layout, err := template.New(DEFAULT_LAYOUT_NAME).Parse(text)
```
This creates a template with a template.namespace.set length of 3: 
- DEFAULT_VALUE_NAME
- "head"
- "body"

STATE BEFORE ADD PARSE TREE:

1. "/" is in the name space as an empty template. 
2. escapeError is wrapped in the Path "/"
3. tc has no tree but a set of two "/" & "body"
4. layout has the ROOT one, but the ns len is 1 (should there be 3, for body and head?)

LIVE AS A GO TEMPLATE FUCTION:
- we generate a live function that at least takes a template name on invocation in html/templates.Template:
```go
    {{ live "template" . }}
```
- this function will be generated by a function returning a function. the closure gives the function access to an in-memory database of valid data requests.
```go
    func live(nam) func(endpoint LiveEndpointRegister, c *http.Request) string {
        return func(data interface{}) string {
            endpoint.Init() // In case we need to initialize the endpoint
            token, id := endpoint.RegisterEndpoint(c *http.Request, name string)
            // we get the data for trigger from interface{} if neccessary
            return "<div id='" + id + "' hx-vals='{ \"token\": \"" + token + "\", \"controller\": \"" + name + "\" }'hx-trigger=''></div>"
        }
    }
```

- maybe we need to make a middleware that injects a custom function into the template:
```go
   func GetLiveMiddleware(endpoint *LiveEndpointRegister) { 
    return injectLiveFunction(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // we get the data for trigger from interface{} if neccessary
            template := r.Context().Value("template").(html/templates.Template)
            template.Funcs(template.FuncMap{"live": live(endpoint, r)})
            
            next(w, r)
        })
    }
   }
```

- then we define an interface for controllers with a handler function, that handles javascript events
```go
    type Controller interface {
        HandleEvent(event string, websocketrequestdata *byte[], ) byte[]
    }
    type PreLoadController interface {
        // Starts to get data as soon as the first request is made
        PreLoadData(r *http.Request) interface{}
    }
```

- With the reflect we get all types that implement this interface and their names, and instantiate them in a map:
```go
    func GetControllers() map[string]Controller {
        controllers := make(map[string]Controller)
        // get all types that implement the Controller interface
        // instantiate them in a map
        return controllers
    }

    func GetPreLoadControllers() map[string]PreLoadController {
        controllers := make(map[string]PreLoadController)
        // get all types that implement the PreLoadController interface
        // instantiate them in a map
        return controllers
    }
```

- At last we define a LiveEnpointRegister which maps a given path to an endpoint, and handles all websocket requests, validating the token:
```go
    type LiveEndpointRegister struct {
        endpoints map[string]Controller
        preloadcontrollers map[string]PreLoadController
        // We will make datamap an interface{} for now
        // Later it will be able to store response code etc etc
        datamap map[string]interface{}
    }

    func (ler *LiveEndpointRegister) Init() {
        if ler.endpoints == nil {
            ler.endpoints = GetControllers()
        }
    }

    func (ler *LiveEndpointRegister) RegisterEndpoint(r *http.Request, name string) (string, string) {
        // get the token from the master key
        // generate a random id
        // check if there is a preload controller for the endpoint, if there is call it and stor its data in a map, which will match
        // token to data:
        preloadcontroller := ler.preloadcontrollers[name]
        if preloadcontroller != nil {
            // some kind of async call must be used here
            data := preloadcontroller.PreLoadData(r)
            // store the data in a map
        }
        return token, id
    }

    // We need a function that returns a handler for websocket requests that sends data to the client as soon as its stored in the map
    func (ler *LiveEndpointRegister) GetWebsocketHandler() http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // get the token from the request
            // get the data from the map
            // send the data to the client
        })
    }
```
